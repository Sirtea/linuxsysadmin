<!DOCTYPE html>
<html>
<head>
	<meta name="generator" content="Hugo 0.60.1" />
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>Linux Sysadmin</title>
	<link rel="stylesheet" href="/style.css" />
	<link rel="icon" href="/favicon.ico" />
	
	<script type="text/javascript" src="//www.FreePrivacyPolicy.com/cookie-consent/releases/3.0.0/cookie-consent.js"></script>
	<script type="text/javascript">
	document.addEventListener('DOMContentLoaded', function () {
		cookieconsent.run({"notice_banner_type":"interstitial","consent_type":"express","palette":"dark","change_preferences_selector":"#changePreferences","language":"es","website_name":"LinuxSysadmin","cookies_policy_url":"https://www.linuxsysadmin.ml/cookies.html"});
	});
	</script>
	<noscript>GDPR Cookie Consent by <a href="https://www.freeprivacypolicy.com/">FreePrivacyPolicy</a></noscript>
	

	<script type="text/plain" cookie-consent="tracking">
	var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
	var doNotTrack = (dnt == "1" || dnt == "yes");
	if (!doNotTrack) {
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		ga('create', 'UA-68486572-1', 'auto');
		ga('set', 'anonymizeIp', true);
		ga('send', 'pageview');
	}
	</script>
	</head>
<body>
<div class="menu">
	<a class="important" href="/">Linux Sysadmin</a>
	<a href="/about.html">Sobre mí</a>
	<a href="/curriculum.html">Curriculum Vitae</a>
	<div class="right">
		<a href="/cookies.html">Cookies</a>
		<a href="/categories.html">Categorías</a>
		<a href="/tags.html">Tags</a>
		<a href="/archives.html">Archivos</a>
	</div>
</div>

<h1>Linux Sysadmin</h1>

<h2 class="article"><a href="/2015/12/construyendo-un-raid-10-en-linux.html">Construyendo un RAID 10 en linux</a></h2>
<p>El otro día estaba habilitando un servidor de <em>mongodb</em> para un entorno de producción. Como me interesaba mejorar el rendimiento de los accesos a disco y no disponía de discos SSD con una durabilidad aceptable, me propuse montar un <em>array de discos</em> en configuración de <strong>RAID 10</strong>, como se recomienda.</p>
<p><a class="article" href="/2015/12/construyendo-un-raid-10-en-linux.html">Seguir leyendo</a></p>
<hr />
<h2 class="article"><a href="/2015/12/construyendo-una-replica-set-en-mongodb.html">Construyendo una replica set en mongodb</a></h2>
<p>Muchas veces nos interesa obtener alta disponibilidad en los servicios que gestionamos. No hay nada mas desagradable que una llamada a las tantas de la noche porque se ha caído un nodo de una base de datos y no damos servicio. Para eso <em>mongodb</em> nos ofrece el mecanismo de replicación.</p>
<p><a class="article" href="/2015/12/construyendo-una-replica-set-en-mongodb.html">Seguir leyendo</a></p>
<hr />
<h2 class="article"><a href="/2015/12/creacion-de-un-livecd-con-debian.html">Creación de un livecd con Debian</a></h2>
<p>Tras ver como las actualizaciones de mis máquinas virtuales <em>VirtualBox</em> expandían mis discos <em>.vdi</em> sin control, quise pasar la herramienta <em>zerofree</em> y un compactado con la herramienta oficial <em>VBoxManage</em>. No quería instalar <em>zerofree</em> de forma permanente y no pude encontrar un <em>livecd</em> que lo tuviera, así que decidí crear uno.</p>
<p><a class="article" href="/2015/12/creacion-de-un-livecd-con-debian.html">Seguir leyendo</a></p>
<hr />
<h2 class="article"><a href="/2015/11/virtualizando-contenedores-lxc-tras-bridge-interno.html">Virtualizando contenedores LXC tras bridge interno</a></h2>
<p>En un artículo anterior propusimos virtualizar contenedores en la red de la máquina <em>host</em>. Sin embargo, puede ser mas interesante esconder los contenedores detrás de una máquina que haga las funciones de <em>host</em> y de <em>firewall</em>. Expondremos una serie de puertos tras la misma dirección <em>IP</em> mediante el protocolo <em>NAT</em>.</p>
<p><a class="article" href="/2015/11/virtualizando-contenedores-lxc-tras-bridge-interno.html">Seguir leyendo</a></p>
<hr />
<h2 class="article"><a href="/2015/11/creando-sistemas-de-ficheros-temporales-con-tmpfs.html">Creando sistemas de ficheros temporales con tmpfs</a></h2>
<p>A veces nos podemos encontrar con un sistema de ficheros lleno que no nos permite completar alguna acción por falta de espacio en disco. En un caso así, existe la posibilidad de sacar un sistema de ficheros completo de memoria, de una forma temporal, usando el sistema de ficheros <em>tmpfs</em>. Otra opción es la de tener un sistema de ficheros temporal, en donde podamos dejar ficheros cuya persistencia no sea necesaria entre reinicios.</p>
<p><a class="article" href="/2015/11/creando-sistemas-de-ficheros-temporales-con-tmpfs.html">Seguir leyendo</a></p>
<hr />
<h2 class="article"><a href="/2015/11/escribiendo-units-en-systemd.html">Escribiendo units en systemd</a></h2>
<p>Cuando se anunció <em>systemd</em> me llamó la atención que además de las funciones estándares de otros sistemas de <em>init</em> (por ejemplo <em>sysvinit</em>), también se ofrecían otras funcionalidades normalmente delegadas a otros procesos, como por ejemplo, la posibilidad de reiniciar procesos automáticamente o de lanzar procesos temporales al estilo de <em>cron</em>.</p>
<p><a class="article" href="/2015/11/escribiendo-units-en-systemd.html">Seguir leyendo</a></p>
<hr />
<h2 class="article"><a href="/2015/11/restart-automatico-de-servicios-con-systemd.html">Restart automático de servicios con systemd</a></h2>
<p>Cuando estamos gestionando un servidor, es posible que se caiga alguno de sus servicios. Esto es especialmente molesto cuando nos interesa tener un <em>uptime</em> elevado. Para conseguirlo, se han utilizado diferentes maneras, desde poner personas a monitorizar en modo 24x7 hasta herramientas auxiliares como gestores tipo <em>runit</em>, <em>supervisor</em> o <em>monit</em>.</p>
<p><a class="article" href="/2015/11/restart-automatico-de-servicios-con-systemd.html">Seguir leyendo</a></p>
<hr />
<h2 class="article"><a href="/2015/11/liberando-memoria-cache.html">Liberando memoria caché</a></h2>
<p>A veces nos encontramos que nuestro sistema linux parece tener la memoria <em>virtual</em> ocupada, cuando no tenemos nada de memoria <em>RSS</em>; esto no es un problema, ya que por la forma de funcionar del <em>memory manager</em> de linux, se conserva &ldquo;por si acaso&rdquo; y se libera cuando realmente se necesita.</p>
<p><a class="article" href="/2015/11/liberando-memoria-cache.html">Seguir leyendo</a></p>
<hr />
<h2 class="article"><a href="/2015/10/ocultando-puertos-con-port-knocking.html">Ocultando puertos con port knocking</a></h2>
<p>En este artículo vamos a enseñar como ocultar un puerto tras el firewall, de forma que solamente se abra tras utilizar el protocolo <em>port knocking</em>. Las tecnologías usadas van a ser <em>firehol</em> como firewall y el demonio <em>knockd</em> ocultando el <em>SSH</em>, aunque vamos a permitir acceder al puerto de HTTP.</p>
<p><a class="article" href="/2015/10/ocultando-puertos-con-port-knocking.html">Seguir leyendo</a></p>
<hr />
<h2 class="article"><a href="/2015/10/virtualizando-contenedores-lxc-con-acceso-red-local.html">Virtualizando contenedores LXC con acceso a la red local</a></h2>
<p>En este tutorial se propone montar un servidor de contenedores LXC, de forma que todos los contenedores queden expuestos a la misma red que el servidor que los aloja. Para protegerlos de posibles ataques de esta red, pondremos un firewall basado en <em>iptables</em> mediante una capa de abstracción llamada <em>firehol</em>.</p>
<p><a class="article" href="/2015/10/virtualizando-contenedores-lxc-con-acceso-red-local.html">Seguir leyendo</a></p>
<hr />

<p class="pagination">
	<a href="/">&laquo;&laquo;</a>
	<a href="/page/20.html">&laquo;</a>
	<a href="/">1</a>
	<a href="/page/2.html">2</a>
	<a href="/page/3.html">3</a>
	<a href="/page/4.html">4</a>
	<a href="/page/5.html">5</a>
	<a href="/page/6.html">6</a>
	<a href="/page/7.html">7</a>
	<a href="/page/8.html">8</a>
	<a href="/page/9.html">9</a>
	<a href="/page/10.html">10</a>
	<a href="/page/11.html">11</a>
	<a href="/page/12.html">12</a>
	<a href="/page/13.html">13</a>
	<a href="/page/14.html">14</a>
	<a href="/page/15.html">15</a>
	<a href="/page/16.html">16</a>
	<a href="/page/17.html">17</a>
	<a href="/page/18.html">18</a>
	<a href="/page/19.html">19</a>
	<a href="/page/20.html">20</a>
	<a class="active" href="/page/21.html">21</a>
</p>
<p class="footer">Copyright &copy; 2015-2020 | Gerard Monells | <a href="https://github.com/sirtea">GitHub</a></p>

</body>
</html>
